name: Ensure public API changes are approved

permissions:
  pull-requests: write
  issues: write

on:
  pull_request:
    types: [opened, edited, reopened, labeled, unlabeled, synchronize]
    branches:
      - "*"

jobs:
  validate-public-api-changes-approval:
    runs-on: [ubuntu-latest]

    steps:
      - name: App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          # API_REVIEWER_ASSIGNER_APP_KEY secret and API_REVIEWER_ASSIGNER_APP_ID variable
          # should be defined at organization level with the private key of the associated github app and its id, respectively. For more details see
          # https://devopsjournal.io/blog/2022/01/03/GitHub-Tokens
          app_id: ${{ vars.API_REVIEWER_ASSIGNER_APP_ID }}
          private_key: ${{ secrets.API_REVIEWER_ASSIGNER_APP_KEY }}

      - name: Check 'api-approved' label
        uses: actions/github-script@v6
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const ApprovalLabel = "api-approved";
            const ApiReviewApproverNotFound = null;
            const Instructions = "PRs changing public APIs requires an associated [API review request issue](https://github.cds.internal.unity3d.com/unity/neutron/issues) labeled as `api-approved` by one member of `api-review-team`. More information on [API review process](https://internaldocs.unity.com/version/neutron/main/development_process/authoring-changes/api-review/overview/)";

            //
            // Returns the login name of user that applied 'api-approved' label or 'null' if label is present.
            //
            async function getLabeler(number) {
              const parameters = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
              };

              const query = `
                      query($owner:String!, $repo:String!, $issue_number:Int!) {
                        repository(owner: $owner, name: $repo) {
                          issue(number: $issue_number) {                                    
                              title, titleHTML,
                              timelineItems(last:100, BEFORE itemTypes:[LABELED_EVENT, UNLABELED_EVENT]) {
                                pageCount,
                                pageInfo { endCursor, hasPreviousPage }, 
                                nodes {
                                  __typename,
                                  ... on LabeledEvent {
                                    label { name },
                                    actor { login }
                                   }
                                }
                              }
                          }
                        }
                      }`;

              try {
                let previousPageCursor = "";
                let keepSearching = true;

                while(keepSearching) {
                  const issueLabelEvents = await github.graphql(query.replace("BEFORE", previousPageCursor), parameters);

                  if (issueLabelEvents.repository.issue.timelineItems.pageCount === 0) {
                    break; // no results.
                  }

                  // lookup connect/disconnect timeline item from last -> first so we take into account the last
                  // occurrence only.
                  const issue = issueLabelEvents.repository.issue;
                  for(index = issue.timelineItems.pageCount - 1; index >= 0; index-- ) {
                    const labelEvent = issue.timelineItems.nodes[index];
                    core.notice(`Checking event for label #${labelEvent.label.name}`);
                    if (labelEvent.label.name == ApprovalLabel) {
                      core.notice(`[Label: ${labelEvent.label.name}, Issue: ${number}] ${labelEvent.__typename}, actor: ${labelEvent.actor.login}`);
                      return labelEvent.__typename === "LabeledEvent" ? labelEvent.actor.login : ApiReviewApproverNotFound;
                    }                            
                  }
                  previousPageCursor = `before: ${issueLabelEvents.repository.issue.timelineItems.pageInfo.endCursor},`;
                  keepSearching = issueLabelEvents.repository.issue.timelineItems.pageInfo.hasPreviousPage;
                }
              }
              catch(exception) {
                core.error(`Unable to retrieve issue ${number}. Exception caught:\n${exception}`);
                return ApiReviewApproverNotFound;
              }
              
              core.notice(`Label '${ApprovalLabel}' no found on issue #${number}`);
              return ApiReviewApproverNotFound;
            }

            async function getApiRequestIssueApprover() {
                const parameters = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_request_number: context.payload.pull_request.number,
                  timeline_items_page_size : 50
                };

                const query = `
                        query($owner:String!, $repo:String!, $pull_request_number:Int!, $timeline_items_page_size:Int!) {
                          repository(owner: $owner, name: $repo) {
                            pullRequest(number: $pull_request_number) {
                              timelineItems(last:$timeline_items_page_size, BEFORE itemTypes:[DISCONNECTED_EVENT, CONNECTED_EVENT]) {
                                pageCount,
                                totalCount,
                                pageInfo { hasPreviousPage, endCursor },
                                nodes {
                                    __typename 
                                  ... on DisconnectedEvent { createdAt, subject { ... on Issue { number, title, labels(first:50) { nodes { name } } } } }
                                  ... on ConnectedEvent { createdAt, subject { ... on Issue { number, title, labels(first:50) { nodes { name } } } } }
                                }
                              }
                            }
                          }
                        }`;

                let previousPageCursor = "";
                let keepSearching = true;
                try {
                  while(keepSearching) {
                    core.notice(`Previous cursor: ${previousPageCursor}`);
                    const pullReqTimelineItems = await github.graphql(query.replace("BEFORE", previousPageCursor), parameters);

                    core.notice(`PageCount: ${pullReqTimelineItems.repository.pullRequest.timelineItems.pageCount} / TotalCount: ${pullReqTimelineItems.repository.pullRequest.timelineItems.totalCount}`);
                    if (pullReqTimelineItems.repository.pullRequest.timelineItems.pageCount === 0) {
                      
                      await github.rest.issues.createComment(
                                    { 
                                        owner: context.repo.owner,
                                        repo: context.repo.repo,
                                        issue_number: context.payload.pull_request.number,
                                        body: "Test 1"
                                      });
                      //"No linked approved Api Review Request issue found." });

                      break; // no results.
                    }

                    // lookup connect/disconnect timeline item from last -> first so we take into account only the last occurrence.
                    const pr = pullReqTimelineItems.repository.pullRequest;
                    for(index = pr.timelineItems.pageCount - 1; index >= 0; index-- ) {
                      const currentTimelineItem = pr.timelineItems.nodes[index];
                      core.notice(`Check issue #${currentTimelineItem.subject.number}`);
                      
                      const approvedLabelIndex = currentTimelineItem.subject.labels.nodes.findIndex(label => label.name === ApprovalLabel);
                      if ( approvedLabelIndex != -1 ) {
                          // is last event a `connection` with an issue labeled as api-approved?
                          return currentTimelineItem.__typename === "ConnectedEvent" ? getLabeler(currentTimelineItem.subject.number) : ApiReviewApproverNotFound;
                      }
                    }
                    
                    previousPageCursor = `before: ${pullReqTimelineItems.repository.pullRequest.timelineItems.pageInfo.endCursor},`;
                    keepSearching = pullReqTimelineItems.repository.pullRequest.timelineItems.pageInfo.hasPreviousPage;
                  }
                } catch(exception) {
                  core.error(`Exception caught retrieving public api approver name (from issue):\n${exception}`);
                }

                await github.rest.issues.createComment( { 
                                      owner: context.repo.owner,
                                      repo: context.repo.repo,
                                      issue_number: context.payload.pull_request.number,
                                      body: "MISSING LINK !!!! :-1: 2"
                                    });
                return ApiReviewApproverNotFound;
            }

            //TODO: Consider using filters on the workflow instead of this query. This way this workflow will only trigger if there are .api files changed.
            //      https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#example-including-paths
            async function prContainsPublicAPIChanges() {
                // Check whether there are any .api files changed.
                const parameters = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_request_number: context.payload.pull_request.number
                };
                
                const query = `
                      query($owner: String!, $repo: String!, $pull_request_number: Int!) { 
                        repository(name: $repo , owner: $owner) { 
                          pullRequest(number: $pull_request_number) {
                            files(first: 100) {
                              totalCount,
                              nodes {
                                path,
                                changeType
                              }
                            }
                          }
                        }
                      }
                      `;

                const pullReqFiles = await github.graphql(query, parameters);
                return pullReqFiles.repository.pullRequest.files.nodes.findIndex(file => file.path.endsWith(".api")) != -1;
            }

            async function isUserPartOfApiReviewTeam(login) {
              const parameters = {
                organization: context.payload.organization.login,
                teamToCheck: "api-review-team"
              };
              
              const query = `
                    query($organization: String!, $teamToCheck: String!) {
                        organization(login: $organization) { team(slug: $teamToCheck) { members { nodes { login } } } }
                    }`;

              const teamMembers = await github.graphql(query, parameters);
              core.notice(`Checking if ${login} is memebr of api-review-team`);
              return teamMembers.organization.team.members.nodes.findIndex(member => member.login === login) != -1;
            }

            //------------------------------------------------------------------------------------------------------------------------------------
            //                                                  Entry point
            //------------------------------------------------------------------------------------------------------------------------------------
            core.notice(`Validating public apis changes in PR: ${context.payload.pull_request.number} (${context.payload.pull_request.title})`);

            if (!prContainsPublicAPIChanges())
            {
                // no public api harmed...
                core.notice(`No public apis changed in PR ${context.payload.pull_request.number}`);
                return;
            }

            let approverName = await getApiRequestIssueApprover();
            if (approverName == ApiReviewApproverNotFound) {
              core.setFailed(`Missing associated api review request issue\n\n${Instructions}`);
              // TODO: comment with the instructions on the PR.
              return;
            }
            else if (! await isUserPartOfApiReviewTeam(approverName)) {
              // TODO: comment with the instructions on the PR.
              core.setFailed(`Api Review approver (${approverName}) must be part of api-review-team (https://github.cds.internal.unity3d.com/orgs/unity/teams/api-review-team)\n\n${Instructions}`);
            }

            core.notice(`Approver name: ${approverName}`);
