#### TODO TODO TODO TODO TODO ######
# - Use a simple isue reference (instead of `development`)
# -

name: Ensure public API changes are approved

permissions:
  pull-requests: write
  issues: write

on:
  pull_request:
    types: [opened, edited, reopened, labeled, unlabeled, synchronize]
    branches:
      - "*"
env:
  EXEMPT_CHECK_TEAM_NAME: ${{ vars.GH_PR_API_VALIDATION_APP_EXEMPT_TEAM_NAME }} # name of the team that can skip this validation by adding the label `exempt-public-api-approval` to the offending PR

jobs:
  validate-public-api-changes-approval:
    runs-on: [ubuntu-latest]

    steps:
      - name: App Token
        uses: actions/create-github-app-token@v1
        id: app-token
        with:
          # API_REVIEWER_ASSIGNER_APP_KEY secret and API_REVIEWER_ASSIGNER_APP_ID variable
          # should be defined at organization level with the private key of the associated github app and its id, respectively. For more details see
          # https://devopsjournal.io/blog/2022/01/03/GitHub-Tokens
          app_id: ${{ vars.GH_PR_API_VALIDATION_APP_ID }}
          private_key: ${{ secrets.GH_PR_API_VALIDATION_APP_KEY }}

      - name: Check 'api-approved' label
        uses: actions/github-script@v6
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const ApprovalLabel = "api-approved";
            const ExemptPublicApiApprovalLabel = "exempt-public-api-approval";
            const ApiReviewApproverNotFound = null;
            const Instructions = "PR changes public APIs and requires an associated [API review request issue](https://github.cds.internal.unity3d.com/unity/THAT_VERSION/issues) labeled as `api-approved` by one member of `api-review-team`. More information on [API review process](https://internaldocs.unity.com/version/THAT_VERSION/main/development_process/authoring-changes/api-review/overview/)";

            //
            // Returns the login name of user that applied 'api-approved' label or 'null' if label is present.
            // --------------------------------------------------------------------------------------------------------------------------------
            async function getLabeler(number) {
              const parameters = {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
              };

              const query = `
                      query($owner:String!, $repo:String!, $issue_number:Int!) {
                        repository(owner: $owner, name: $repo) {
                          issue(number: $issue_number) {                                    
                              title, titleHTML,
                              timelineItems(last:100, BEFORE itemTypes:[LABELED_EVENT, UNLABELED_EVENT]) {
                                pageCount,
                                pageInfo { startCursor, hasPreviousPage }, 
                                nodes {
                                  __typename,
                                  ... on LabeledEvent {
                                    label { name },
                                    actor { login }
                                   }
                                }
                              }
                          }
                        }
                      }`;

              try {
                let previousPageCursor = "";
                let keepSearching = true;

                while(keepSearching) {
                  const issueLabelEvents = await github.graphql(query.replace("BEFORE", previousPageCursor), parameters);

                  if (issueLabelEvents.repository.issue.timelineItems.pageCount === 0) {
                    break; // no results.
                  }

                  // lookup connect/disconnect timeline item from last -> first so we take into account the last
                  // occurrence only.
                  const issue = issueLabelEvents.repository.issue;
                  for(index = issue.timelineItems.pageCount - 1; index >= 0; index-- ) {
                    const labelEvent = issue.timelineItems.nodes[index];
                    core.notice(`Checking event for label #${labelEvent.label.name}`);
                    
                    if (labelEvent.label.name == ApprovalLabel) {
                      core.notice(`[Label: ${labelEvent.label.name}, Issue: ${number}] ${labelEvent.__typename}, actor: ${labelEvent.actor.login}`);
                      return labelEvent.__typename === "LabeledEvent" ? labelEvent.actor.login : ApiReviewApproverNotFound;
                    }                            
                  }
                  previousPageCursor = `before: ${issueLabelEvents.repository.issue.timelineItems.pageInfo.startCursor},`;
                  keepSearching = issueLabelEvents.repository.issue.timelineItems.pageInfo.hasPreviousPage;
                }
              }
              catch(exception) {
                core.error(`Unable to retrieve issue ${number}. Exception caught:\n${exception}`);
                return ApiReviewApproverNotFound;
              }
              
              core.notice(`Label '${ApprovalLabel}' no found on issue #${number}`);
              return ApiReviewApproverNotFound;
            }

            // --------------------------------------------------------------------------------------------------------------------------------
            async function getApiRequestIssueApprover() {
                const parameters = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_request_number: context.payload.pull_request.number,
                  timeline_items_page_size : 50
                };

                const query = `
                        query($owner:String!, $repo:String!, $pull_request_number:Int!, $timeline_items_page_size:Int!) {
                          repository(owner: $owner, name: $repo) {
                            pullRequest(number: $pull_request_number) {
                              timelineItems(last:$timeline_items_page_size, BEFORE itemTypes:[DISCONNECTED_EVENT, CONNECTED_EVENT]) {
                                pageCount,
                                totalCount,
                                pageInfo { hasPreviousPage, startCursor },
                                nodes {
                                    __typename 
                                  ... on DisconnectedEvent { createdAt, subject { ... on Issue { number, title, labels(first:50) { nodes { name } } } } }
                                  ... on ConnectedEvent { createdAt, subject { ... on Issue { number, title, labels(first:50) { nodes { name } } } } }
                                }
                              }
                            }
                          }
                        }`;

                let previousPageCursor = "";
                let keepSearching = true;
                try {
                  while(keepSearching) {
                    core.notice(`Previous cursor: ${previousPageCursor}`);
                    const pullReqTimelineItems = await github.graphql(query.replace("BEFORE", previousPageCursor), parameters);

                    core.notice(`PageCount: ${pullReqTimelineItems.repository.pullRequest.timelineItems.pageCount} / TotalCount: ${pullReqTimelineItems.repository.pullRequest.timelineItems.totalCount}`);
                    if (pullReqTimelineItems.repository.pullRequest.timelineItems.pageCount === 0) {
                      break; // no results.
                    }

                    // lookup connect/disconnect timeline item from last -> first so we take into account only the last occurrence.
                    const pr = pullReqTimelineItems.repository.pullRequest;
                    for(index = pr.timelineItems.pageCount - 1; index >= 0; index-- ) {
                      const currentTimelineItem = pr.timelineItems.nodes[index];
                      core.notice(`Check issue #${currentTimelineItem.subject.number}`);
                      
                      const approvedLabelIndex = currentTimelineItem.subject.labels.nodes.findIndex(label => label.name === ApprovalLabel);
                      if ( approvedLabelIndex != -1 ) {
                          // is last event a `connection` with an issue labeled as api-approved?
                          return currentTimelineItem.__typename === "ConnectedEvent" ? getLabeler(currentTimelineItem.subject.number) : ApiReviewApproverNotFound;
                      }
                    }
                    
                    previousPageCursor = `before: ${pullReqTimelineItems.repository.pullRequest.timelineItems.pageInfo.startCursor},`;
                    keepSearching = pullReqTimelineItems.repository.pullRequest.timelineItems.pageInfo.hasPreviousPage;
                  }
                } catch(exception) {
                  core.error(`Exception caught retrieving public api approver name (from issue):\n${exception}`);
                }

                return ApiReviewApproverNotFound;
            }

            //TODO: Consider using filters on the workflow instead of this query. This way this workflow will only trigger if there are .api files changed.
            //      https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore
            //      If workflow is marked as `required` this filter cannot be used.
            // --------------------------------------------------------------------------------------------------------------------------------
            async function prContainsPublicAPIChanges() {
                // Check whether there are any .api files changed.
                const parameters = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_request_number: context.payload.pull_request.number
                };
                
                const query = `
                      query($owner: String!, $repo: String!, $pull_request_number: Int!) { 
                        repository(name: $repo , owner: $owner) { 
                          pullRequest(number: $pull_request_number) {
                            files(first: 1 NEXT_BATCH) {
                              pageInfo { hasNextPage, endCursor }
                              nodes { path, changeType }
                            }
                          }
                        }
                      }`;

                let nextCursor = "";
                while (nextCursor !== null) {
                  const pullReqFiles = await github.graphql(query.replace("NEXT_BATCH", nextCursor), parameters);
                  if (pullReqFiles.repository.pullRequest.files.nodes.findIndex(file => file.path.endsWith(".api")) != -1)
                     return true;

                  nextCursor = pullReqFiles.repository.pullRequest.files.pageInfo.hasNextPage ? `, after: "${pullReqFiles.repository.pullRequest.files.pageInfo.endCursor}"` :  null;
                }
            }

            // --------------------------------------------------------------------------------------------------------------------------------
            async function isUserPartOfTeam(login, teamName) {
              const parameters = {
                organization: context.payload.organization.login,
                teamToCheck: teamName
              };
              
              const query = `
                    query($organization: String!, $teamToCheck: String!) {
                        organization(login: $organization) { team(slug: $teamToCheck) { members { nodes { login } } } }
                    }`;

              const teamMembers = await github.graphql(query, parameters);
              core.notice(`Checking if ${login} is member of ${teamName} team.`);
              
              return teamMembers.organization.team !== null && teamMembers.organization.team.members.nodes.findIndex(member => member.login === login) != -1;
            }

            
            // --------------------------------------------------------------------------------------------------------------------------------
            async function addCommentWithApiReviewProcessInstructionIfNotDoneYet(message) {
              const parameters = {
                  owner: context.repo.owner,
                  repository: context.repo.repo,
                  pull_request_number: context.payload.pull_request.number
              };

              const alreadyReportedQuery = `query($repository: String!, $owner: String!, $pull_request_number: Int!) {
                                              repository(name: $repository, owner: $owner) {
                                                pullRequest(number: $pull_request_number) {      
                                                  comments(first: 50) {
                                                    totalCount,
                                                    pageInfo { hasNextPage, endCursor AFTER }
                                                    nodes {
                                                      url,
                                                      author { login, __typename },
                                                      body
                                                    }
                                                  }
                                                }
                                              }
                                            }`;
              let afterAnchor = "";
              while(true) {
                const comments = await github.graphql(alreadyReportedQuery.replace("AFTER", afterAnchor), parameters)
                if (comments.repository.pullRequest.comments.totalCount === 0) {
                  break;
                }

                const foundMatch = comments.repository.pullRequest.comments.nodes.find(comment => comment.body === message);
                if (foundMatch !== undefined) {
                  core.notice(`Comment guiding devs on how to get public api changes approved found (author: ${foundMatch.author.login}, url=${foundMatch.url})`);
                  return; // found a matching comment.. lets not add one more...
                }

                if (!comments.repository.pullRequest.comments.pageInfo.hasNextPage)
                  break; // no more results to check...

                afterAnchor = `, after: ${comments.repository.pullRequest.comments.pageInfo.endCursor}`;
              }

              await github.rest.issues.createComment( { 
                                      owner: context.repo.owner,
                                      repo: context.repo.repo,
                                      issue_number: context.payload.pull_request.number,
                                      body: message
                                    });
            }


            // --------------------------------------------------------------------------------------------------------------------------------
            async function failWithCommentIfNotExempt(failureMessage, comment) {
              if (context.payload.pull_request.labels.findIndex(node => node.name === ExemptPublicApiApprovalLabel) !== -1) {
                const exemptApiApprovalQuery = `query($owner: String!, $repo: String!, $prNumber : Int!) { repository(owner:$owner, name:$repo) { pullRequest(number:$prNumber) { 
                                                    timelineItems(last:100, itemTypes:[LABELED_EVENT]) {
                                                      nodes {
                                                        ... on LabeledEvent   { id, label { name }, actor { login } }
                                                      }
                                                    }
                                                } } }`;

                const results = await github.graphql(exemptApiApprovalQuery, {
                                                        owner: context.repo.owner,
                                                        repo: context.repo.repo,
                                                        prNumber: context.payload.pull_request.number
                                                    });
                
                let index = results.repository.pullRequest.timelineItems.nodes.length - 1;
                while (index >= 0) {
                  let current = results.repository.pullRequest.timelineItems.nodes[index];
                  if (current.label.name === ExemptPublicApiApprovalLabel)
                     break;

                  index--;
                }

                if (index !== -1) {
                  core.notice("api approval exemption label found... checking author.");
                  const labeler = results.repository.pullRequest.timelineItems.nodes[index].actor.login;
                                    
                  const exemptApproversTeam = process.env.EXEMPT_CHECK_TEAM_NAME || "(GH_PR_API_VALIDATION_APP_EXEMPT_TEAM_NAME github variable not defined)";
                  if (await isUserPartOfTeam(labeler, exemptApproversTeam)) {
                    addCommentWithApiReviewProcessInstructionIfNotDoneYet(`Unapproved public api changes exempted by @${labeler}.`);
                    return;
                  }
                  else {
                    core.warning(`Found unapproved public api changes exemption label (${ExemptPublicApiApprovalLabel}) in PR ${context.payload.pull_request.number} but labeler (${labeler}) is not part of ${exemptApproversTeam} team or that team does not exist in Unity organization. Ignoring exemption.`);
                  }
                }
              }

              // it is not exempt... lets fail.
              core.setFailed(failureMessage);
              addCommentWithApiReviewProcessInstructionIfNotDoneYet(comment);
            }

            //------------------------------------------------------------------------------------------------------------------------------------
            //                                                  Entry point
            //------------------------------------------------------------------------------------------------------------------------------------
            core.notice(`Validating public apis changes in PR: ${context.payload.pull_request.number} (${context.payload.pull_request.title})`);

            if (!await prContainsPublicAPIChanges())
            {
                // no public api harmed...
                core.notice(`No public apis changed in PR ${context.payload.pull_request.number}`);
                return;
            }

            let approverName = await getApiRequestIssueApprover();
            if (approverName == ApiReviewApproverNotFound) {
              failWithCommentIfNotExempt(
                `Missing associated api review request issue\n\n${Instructions}`,
                `${Instructions}\n\nNo linked approved Api Review Request issue found. See [api review process documentation](https://internaldocs.unity.com/version/THAT_VERSION/main/development_process/authoring-changes/api-review/overview/#linking-approval-with-pr)`);
            }
            else if (! await isUserPartOfTeam(approverName, "api-review-team")) {
              failWithCommentIfNotExempt(
                `Api Review approver (${approverName}) must be part of api-review-team (https://github.cds.internal.unity3d.com/orgs/unity/teams/api-review-team)\n\n${Instructions}`,
                `Api review approver (${approverName}) must be part of [api-review-team](https://github.cds.internal.unity3d.com/orgs/unity/teams/api-review-team)\n\n${Instructions}`);
            }
            else {
              core.notice(`Approver name: ${approverName}`);
            }